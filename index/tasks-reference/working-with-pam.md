## 使用 PAM

PAM（可插入身份验证模块）是一种允许不同的应用程序使用各种指定的参数进行身份验证的机制，例如使用 passwd / shadow 文件，Kerberos 服务器，LDAP 服务器或 NT 域服务器（使用 Samba）。

使用 PAM，程序只需要对给定的登录类（在 pam.d 文件中定义）进行身份验证，而 PAM 框架将负责调用将提供身份验证的模块。

## `pamd`文件的结构

但是，让我们看一下`pamd`文件的结构。首先，将 pamd 文件放置在`/etc/pam.d`中，并将它们构造为每行一条语句。该语句由 3 或 4 个标记组成：

- 第一个标记指定要为其执行语句的服务类型。有四种类型：
  - _account_，用于检查用户帐户的有效性。
  - _auth_，它使用密码或其他方式（例如生物特征识别和智能卡设备）验证用户的身份。
  - _password_，它负责更改用户的密码。
  - _session_，包括诸如检查用户有效性或主目录的安装/卸载之类的任务，这些任务在启动和关闭用户会话之前和之后执行。
- 第二个令牌是控件，它告诉 PAM 如何对指定模块进行身份验证失败和成功认证：
  - _requisite_，失败会导致过程终止。
  - _required_，失败将导致服务失败，但在此之前，所有其他模块都在执行。
  - _sufficient_，如果在此之前没有任何*必需*的模块失败，则此模块的成功将导致身份验证成功。
  - _optional_，在这种情况下，如果不是唯一的模块，则失败或成功将被忽略，在这种情况下，成功或失败会使认证成功或失败。
- 第三个令牌是针对该类型服务执行的模块； PAM 模块是可扩展的，顾名思义是可插拔的。结果是，可以针对 PAM 实现构建少量的默认模块和一些外部可选模块，以定义其他身份验证方法。一些文档指出我们需要指定模块的完整路径，但这会造成问题，因为并非所有系统都将模块安装在同一位置：Gentoo 上的 Linux-PAM 通常设置为从`/lib/security`加载它们，但是例如在 AMD64 上，它变成`/lib64/security`。结果是，提供完整路径将导致无法使用的`pamd`文件，正确的处理方法是指出模块名称 —— PAM 实现将负责查找模块。
- 最后一个令牌（可以包含多个项目）描述传递给模块的参数。这些是模块相关的。
- `pam_deny.so`，`pam_permit.so` —— 他们只是报告失败或成功
- 如果用户是 root 用户，则`pam_rootok.so`报告成功，否则失败
- `pam_nologin.so`检查是否存在/etc/nologin 文件，并给出阻止用户登录的原因 —— 例如，在更好地避免用户登录受到破坏的系统时使用它
- `pam_securetty.so`检查登录是否在由配置文件认为安全的 tty 中完成（取决于实现）
- `pam_unix.so`是 Unix 系统的基本模块，它仅使用`/etc/passwd`和`/etc/shadow`检查用户/密码对。

还有其他模块可用于针对数据库（mysql 或 postgresql），LDAP 目录或 NT 域（使用 samba）进行更复杂的身份验证。这在瘦客户机或胖客户机上非常有用，在瘦客户机上，用户对所有计算机都有唯一的登录名。另一个有用的地方是服务器集群，它们需要针对某些服务的单一来源进行身份验证，例如邮件和 ftp 服务器。

但是对于台式机系统，所有不同的服务，例如邮件服务器，ftp 服务器，ssh 等，仅需要以用户登录系统的相同方式进行身份验证。

为实现此目的，RedHat 为 Linux-PAM（没有依赖其他身份验证方案的方式）开发了`pam_stack.so`模块，该模块接受`login=<login service to use>`作为参数，告诉 PAM 执行该操作。指定服务的身份验证堆栈。

不幸的是，该模块依赖于 Linux-PAM 的内部数据结构和对其他 PAM 实现无效的假设，因此它是完全不可移植的。并非在 Linux-PAM 的所有实现中都使用它（例如，参见使用 Linux-PAM 但不提供`pam_stack.so`的 MacOS X），因此并非在所有 Linux 发行版中都存在。

当 AltLinux 开发人员为控件令牌添加新指令：_include_，出现了一个解决方案。从 Linux-PAM 0.78 开始，可以使用该控制令牌来执行与必需的`pam_stack.so`相同的操作，将模块名称替换为要模拟的登录类的名称。

通过这种方式，而不是加载一个模块，该模块又重新加载 pam，该选项由 PAM 实现直接解析，PAM 实现将加载另一个登录类并负责执行该登录类。

## 安装`pamd`文件

`pamd`文件的正确位置是`/etc/pam.d`，但是手动检查`pam` USE 标志来安装它们很棘手，并且不遵循与 initd 和 confd 文件相同的路径，因此解决方案是使用`pam` eclass。

在`pam` eclass 中，有一些功能为`pamd`文件（`dopamd`和`newpamd`，其用法与相似的`do*`和`new*`函数相同）和`/etc/security`文件（`dopamsecurity`和`newpamsecurity`，需要第一个参数）提供安装工具。是`/etc/security`的子目录，其中将安装文件。这些功能组已经负责验证是否使`pam` USE 标志对于软件包是可选的 —— 如果是这种情况，并且禁用了该标志，则将跳过`pamd`文件。

许多`pamd`文件仅使用`system-auth`登录类中的一种或多种 auth 类型，这是为常见桌面系统上的大多数服务提供登录功能的基础类。与其为此在`${FILESDIR}`中添加`pamd`文件，不如使用`pamd_mimic_system`函数。此函数带有一系列参数-第一个参数是登录类的名称（/etc/pam.d 中的 pamd 文件的名称）；其他是需要使用系统身份验证的身份验证类型。

例如，像这样的调用：

```bash
pamd_mimic_system foo auth password
```

安装一个`/etc/pam.d/foo`文件，其中包含：

```bash
auth        include     system-auth
password    include     system-auth
```

仅使用`system-auth`登录类。

## 安装`PAM`模块

由于在不同实现的不同目录中查找 PAM 模块，这也取决于具有多个应用程序二进制接口的架构的 libdir 名称，因此通常无法信任模块所声明的默认目录（如果模块声明了默认目录）。此解决方案也在`pam` eclass 中。函数`getpam_mod_dir`返回用于当前实现/体系结构的正确目录。

当 PAM 模块没有提供自行安装软件包的方法（例如`Makefile`或安装脚本）时，还有`dopammod`和`newpammod`函数负责将模块安装在正确的目录中。
